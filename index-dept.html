<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Emory DSCI Faculty Research Network</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #f8f9fa;
    color: #333;
    overflow: hidden;
    height: 100vh;
  }

  #header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    padding: 16px 24px;
    background: linear-gradient(180deg, rgba(248,249,250,0.97) 0%, rgba(248,249,250,0) 100%);
    pointer-events: none;
  }

  #header h1 {
    font-size: 20px;
    font-weight: 600;
    color: #012169;
    letter-spacing: -0.3px;
    pointer-events: auto;
  }

  #header p {
    font-size: 13px;
    color: #777;
    margin-top: 2px;
    pointer-events: auto;
  }

  #graph { width: 100%; height: 100vh; }

  /* Legend */
  #legend {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 10;
    background: rgba(255,255,255,0.95);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 10px;
    padding: 14px 18px;
    backdrop-filter: blur(10px);
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
  }

  #legend h3 {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #999;
    margin-bottom: 8px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
    font-size: 12px;
    color: #555;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .legend-item:hover { color: #012169; }
  .legend-item.dimmed { opacity: 0.3; }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* Tooltip */
  #tooltip {
    position: fixed;
    z-index: 20;
    background: rgba(255,255,255,0.97);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 10px;
    padding: 14px 18px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    max-width: 340px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
  }

  #tooltip.visible { opacity: 1; }

  #tooltip h4 {
    font-size: 15px;
    font-weight: 600;
    color: #012169;
    margin-bottom: 6px;
  }

  #tooltip .area-tags {
    margin-bottom: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
  }

  #tooltip .area-tag {
    font-size: 11px;
    padding: 2px 8px;
    border-radius: 4px;
    display: inline-block;
  }

  #tooltip .stat {
    font-size: 12px;
    color: #777;
    margin-bottom: 2px;
  }

  #tooltip .topics {
    font-size: 11px;
    color: #999;
    margin-top: 6px;
    line-height: 1.5;
  }

  /* Edge tooltip */
  #edge-tooltip {
    position: fixed;
    z-index: 20;
    background: rgba(255,255,255,0.97);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 10px;
    padding: 14px 18px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    max-width: 360px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
  }

  #edge-tooltip.visible { opacity: 1; }

  #edge-tooltip h4 {
    font-size: 14px;
    color: #012169;
    margin-bottom: 8px;
  }

  #edge-tooltip .edge-detail {
    font-size: 12px;
    color: #555;
    margin-bottom: 3px;
  }

  #edge-tooltip .paper-list {
    font-size: 11px;
    color: #777;
    margin-top: 6px;
    line-height: 1.5;
  }

  /* Controls */
  #controls {
    position: fixed;
    top: 16px;
    right: 20px;
    z-index: 10;
    display: flex;
    gap: 8px;
  }

  .ctrl-btn {
    background: rgba(255,255,255,0.95);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 8px;
    color: #555;
    font-size: 12px;
    padding: 6px 12px;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: all 0.15s;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
  }

  .ctrl-btn:hover { color: #012169; border-color: rgba(1,33,105,0.3); }
  .ctrl-btn.active { color: #fff; background: #012169; border-color: #012169; }

  /* Edge weight slider */
  #weight-control {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 10;
    background: rgba(255,255,255,0.95);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 10px;
    padding: 14px 18px;
    backdrop-filter: blur(10px);
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
  }

  #weight-control label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #999;
    display: block;
    margin-bottom: 6px;
  }

  #weight-control input[type=range] {
    width: 180px;
    accent-color: #012169;
  }

  #weight-control .val {
    font-size: 12px;
    color: #777;
    margin-top: 4px;
  }

  /* Detail panel */
  #detail-panel {
    position: fixed;
    top: 0;
    right: -400px;
    width: 380px;
    height: 100vh;
    z-index: 30;
    background: rgba(255,255,255,0.97);
    border-left: 1px solid rgba(0,0,0,0.1);
    backdrop-filter: blur(16px);
    box-shadow: -4px 0 20px rgba(0,0,0,0.08);
    transition: right 0.25s ease;
    display: flex;
    flex-direction: column;
  }

  #detail-panel.open { right: 0; }

  #detail-panel .panel-header {
    padding: 18px 20px 14px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-shrink: 0;
  }

  #detail-panel .panel-header h3 {
    font-size: 17px;
    font-weight: 600;
    color: #012169;
    line-height: 1.3;
    margin-right: 12px;
  }

  #detail-panel .panel-close {
    background: none;
    border: 1px solid rgba(0,0,0,0.12);
    border-radius: 6px;
    color: #999;
    font-size: 18px;
    width: 28px;
    height: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.15s;
  }

  #detail-panel .panel-close:hover { color: #333; border-color: rgba(0,0,0,0.3); }

  #detail-panel .panel-body {
    padding: 16px 20px;
    overflow-y: auto;
    flex: 1;
  }

  #detail-panel .panel-section {
    margin-bottom: 18px;
  }

  #detail-panel .panel-section h4 {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #999;
    margin-bottom: 8px;
  }

  #detail-panel .panel-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 8px;
  }

  #detail-panel .panel-tag {
    font-size: 11px;
    padding: 3px 9px;
    border-radius: 4px;
  }

  #detail-panel .panel-stat {
    font-size: 13px;
    color: #555;
    margin-bottom: 4px;
  }

  #detail-panel .panel-stat strong { color: #333; }

  #detail-panel .panel-link {
    font-size: 12px;
    color: #012169;
    text-decoration: none;
    display: inline-block;
    margin-bottom: 4px;
  }

  #detail-panel .panel-link:hover { color: #0240b0; text-decoration: underline; }

  #detail-panel .paper-item {
    font-size: 12px;
    color: #555;
    margin-bottom: 8px;
    line-height: 1.4;
  }

  #detail-panel .paper-item .paper-title { color: #333; }
  #detail-panel .paper-item .paper-meta { font-size: 11px; color: #999; margin-top: 1px; }

  #detail-panel .conn-item {
    font-size: 12px;
    color: #555;
    margin-bottom: 4px;
    cursor: pointer;
    transition: color 0.1s;
  }

  #detail-panel .conn-item:hover { color: #012169; }

  #detail-panel .topic-list, #detail-panel .journal-list {
    font-size: 12px;
    color: #666;
    line-height: 1.6;
  }

  /* Embed mode — for inclusion in a larger page */
  body.embed #header,
  body.embed #controls,
  body.embed #weight-control { display: none; }

  body.embed #legend {
    background: none;
    border: none;
    box-shadow: none;
    backdrop-filter: none;
    padding: 10px 12px;
  }

  body.embed #legend h3 {
    color: #bbb;
    font-size: 10px;
  }

  body.embed .legend-item {
    font-size: 11px;
    color: #888;
  }

  body.embed { height: 500px; max-height: 500px; }
  body.embed #graph { height: 500px; max-height: 500px; }
</style>
</head>
<body>

<div id="header">
  <h1>Emory Data &amp; Decision Sciences — Research Network</h1>
  <p>Faculty connected by co-authorship, shared citations, topics, and journals</p>
</div>

<svg id="graph"></svg>

<div id="legend"></div>

<div id="controls">
  <button class="ctrl-btn active" data-edge="all">All edges</button>
  <button class="ctrl-btn" data-edge="coauthor">Co-authored</button>
  <button class="ctrl-btn" data-edge="refs">Shared refs</button>
  <button class="ctrl-btn" data-edge="topics">Shared topics</button>
</div>

<div id="weight-control">
  <label>Min edge weight</label>
  <input type="range" id="weight-slider" min="0" max="100" value="5">
  <div class="val">Showing edges with weight &ge; <span id="weight-val">5</span></div>
</div>

<div id="tooltip"></div>
<div id="edge-tooltip"></div>
<div id="detail-panel">
  <div class="panel-header">
    <h3 id="panel-title"></h3>
    <button class="panel-close" onclick="closePanel()">&times;</button>
  </div>
  <div class="panel-body" id="panel-body"></div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const EMBED = new URLSearchParams(location.search).has("embed");
if (EMBED) document.body.classList.add("embed");

const COLORS = {
  "Political Science": "#f97316",
  "NLP / Computational": "#06b6d4",
  "Statistics / Causal Inference": "#8b5cf6",
  "Digital Humanities": "#ec4899",
  "Biology / Neuroscience": "#22c55e",
  "Sociology / Public Health": "#eab308",
  "Other": "#64748b",
};

function nodeRadius(d) {
  return Math.max(7, Math.min(Math.sqrt(d.citedby) / 5, 28));
}

// Compute concentric ring radii so each ring's area is proportional to share.
// Returns array of {area, innerR, outerR} sorted smallest-inside to largest-outside.
function ringLayout(areas, R) {
  // Sort ascending by share so largest is outermost
  const sorted = [...areas].sort((a, b) => a.share - b.share);
  let cumShare = 0;
  return sorted.map(a => {
    const innerR = R * Math.sqrt(cumShare);
    cumShare += a.share;
    const outerR = R * Math.sqrt(cumShare);
    return { area: a.area, share: a.share, innerR, outerR };
  });
}

function nodeHasArea(d, area) {
  return d.areas && d.areas.some(a => a.area === area);
}

let graph, simulation, svg, g, link, node;
let edgeFilter = "all";
let weightThreshold = 5;
let highlightAreas = new Set();

async function init() {
  const resp = await fetch("data/graph.json");
  graph = await resp.json();

  const width = window.innerWidth;
  const height = EMBED ? 500 : window.innerHeight;

  svg = d3.select("#graph")
    .attr("width", width)
    .attr("height", height)
    .style("max-height", height + "px");

  // Defs for glow
  const defs = svg.append("defs");
  const glow = defs.append("filter").attr("id", "glow");
  glow.append("feGaussianBlur").attr("stdDeviation", 1.5).attr("result", "blur");
  glow.append("feMerge").selectAll("feMergeNode")
    .data(["blur", "SourceGraphic"])
    .join("feMergeNode")
    .attr("in", d => d);

  g = svg.append("g");

  const zoom = d3.zoom()
    .scaleExtent([0.3, 5])
    .on("zoom", e => g.attr("transform", e.transform));
  svg.call(zoom);

  link = g.append("g").attr("class", "links").selectAll("line");
  node = g.append("g").attr("class", "nodes").selectAll("g");

  simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(d => d.id).distance(d => {
      return 120 / Math.sqrt(Math.max(d.weight / 20, 0.5));
    }))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(d => nodeRadius(d) + 4))
    .force("x", d3.forceX(width / 2).strength(0.03))
    .force("y", d3.forceY(height / 2).strength(EMBED ? 0.08 : 0.03));

  buildLegend();
  setupControls();
  update();

  if (!EMBED) {
    setTimeout(() => {
      svg.transition().duration(800).call(
        zoom.transform,
        d3.zoomIdentity.translate(width * 0.1, height * 0.1).scale(0.85)
      );
    }, 2000);
  }
}

function getFilteredEdges() {
  return graph.edges.filter(e => {
    if (e.weight < weightThreshold) return false;
    if (edgeFilter === "coauthor") return e.coauthor_count > 0;
    if (edgeFilter === "refs") return e.shared_refs > 0;
    if (edgeFilter === "topics") return e.shared_topics > 0;
    return true;
  });
}

function getConnectedNodes(edges) {
  const connected = new Set();
  edges.forEach(e => {
    connected.add(typeof e.source === 'object' ? e.source.id : e.source);
    connected.add(typeof e.target === 'object' ? e.target.id : e.target);
  });
  return connected;
}

function update() {
  const filteredEdges = getFilteredEdges();
  const connectedNodes = getConnectedNodes(filteredEdges);
  const visibleNodes = graph.nodes;

  // Links
  link = link.data(filteredEdges, d =>
    `${typeof d.source === 'object' ? d.source.id : d.source}-${typeof d.target === 'object' ? d.target.id : d.target}`
  );
  link.exit().remove();
  const linkEnter = link.enter()
    .append("line")
    .on("mouseenter", showEdgeTooltip)
    .on("mouseleave", hideEdgeTooltip)
    .on("click", clickEdge)
    .style("cursor", "pointer");
  link = linkEnter.merge(link)
    .attr("stroke", d => d.coauthor_count > 0 ? "rgba(0,0,0,0.25)" : "rgba(0,0,0,0.08)")
    .attr("stroke-width", d => Math.max(Math.min(Math.sqrt(d.weight / 5), 6), 3));

  // Nodes
  node = node.data(visibleNodes, d => d.id);
  node.exit().remove();

  const nodeEnter = node.enter().append("g")
    .attr("class", "node-group")
    .style("cursor", "pointer")
    .call(d3.drag()
      .on("start", dragStart)
      .on("drag", dragging)
      .on("end", dragEnd)
    )
    .on("mouseenter", (event, d) => { showTooltip(event, d); highlightNeighbors(d); })
    .on("mouseleave", (event, d) => { hideTooltip(); unhighlightNeighbors(); })
    .on("click", clickNode);

  // Draw concentric rings for each entering node
  nodeEnter.each(function(d) {
    const g = d3.select(this);
    const R = nodeRadius(d);
    const areas = d.areas && d.areas.length ? d.areas : [{area: "Other", share: 1}];
    const rings = ringLayout(areas, R);

    // Glow background circle
    g.append("circle")
      .attr("r", R)
      .attr("fill", "none")
      .attr("stroke", COLORS[d.primary_area] || COLORS["Other"])
      .attr("stroke-width", 1.5)
      .attr("stroke-opacity", 0.3)
      .attr("filter", "url(#glow)");

    // Concentric rings (draw outside-in so outer ring is behind)
    const arc = d3.arc().startAngle(0).endAngle(2 * Math.PI);
    g.selectAll(".ring-slice")
      .data(rings.slice().reverse())
      .join("path")
      .attr("class", "ring-slice")
      .attr("d", ring => arc({ innerRadius: ring.innerR, outerRadius: ring.outerR }))
      .attr("fill", ring => COLORS[ring.area] || COLORS["Other"])
      .attr("fill-opacity", 0.7)
      .attr("stroke", "#f8f9fa")
      .attr("stroke-width", areas.length > 1 ? 0.8 : 0);
  });

  // Labels
  nodeEnter.append("text")
    .text(d => {
      const parts = d.id.split(" ");
      if (parts.length > 2) return parts[0][0] + ". " + parts.slice(-1)[0];
      return parts[0][0] + ". " + parts.slice(1).join(" ");
    })
    .attr("dx", d => nodeRadius(d) + 5)
    .attr("dy", 4)
    .attr("font-size", "11px")
    .attr("fill", "#444")
    .attr("font-weight", 500);

  node = nodeEnter.merge(node);

  // Opacity logic
  applyOpacity(connectedNodes);

  // Simulation
  simulation.nodes(visibleNodes);
  simulation.force("link").links(filteredEdges);
  simulation.alpha(0.5).restart();

  simulation.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);
    node.attr("transform", d => `translate(${d.x},${d.y})`);
  });
}

function nodeMatchesAreas(d) {
  return d.areas && d.areas.some(a => highlightAreas.has(a.area));
}

function applyOpacity(connectedNodes) {
  if (highlightAreas.size > 0) {
    node.selectAll(".ring-slice")
      .attr("fill-opacity", function() {
        const d = d3.select(this.parentNode).datum();
        return nodeMatchesAreas(d) ? 0.85 : 0.1;
      });
    node.select("circle")
      .attr("stroke-opacity", function() {
        const d = d3.select(this.parentNode).datum();
        return nodeMatchesAreas(d) ? 0.3 : 0.05;
      });
    node.select("text")
      .attr("opacity", d => nodeMatchesAreas(d) ? 1 : 0.12);
    link.attr("opacity", d => {
      const s = typeof d.source === 'object' ? d.source : null;
      const t = typeof d.target === 'object' ? d.target : null;
      if (!s || !t) return 0.05;
      return (nodeMatchesAreas(s) || nodeMatchesAreas(t)) ? 1 : 0.05;
    });
  } else {
    const connected = connectedNodes || getConnectedNodes(getFilteredEdges());
    node.selectAll(".ring-slice")
      .attr("fill-opacity", function() {
        const d = d3.select(this.parentNode).datum();
        return connected.has(d.id) ? 0.75 : 0.15;
      });
    node.select("circle")
      .attr("stroke-opacity", function() {
        const d = d3.select(this.parentNode).datum();
        return connected.has(d.id) ? 0.25 : 0.06;
      });
    node.select("text")
      .attr("opacity", d => connected.has(d.id) ? 1 : 0.25);
    link.attr("opacity", 1);
  }
}

function buildLegend() {
  const legend = d3.select("#legend");
  legend.append("h3").text("Research areas");

  Object.entries(COLORS).forEach(([name, color]) => {
    if (name === "Other") return;
    // Count nodes that have ANY share in this area
    const count = graph.nodes.filter(n => nodeHasArea(n, name)).length;
    const item = legend.append("div")
      .attr("class", "legend-item")
      .on("click", () => {
        if (highlightAreas.has(name)) highlightAreas.delete(name);
        else highlightAreas.add(name);
        d3.selectAll(".legend-item").classed("dimmed", function() {
          if (highlightAreas.size === 0) return false;
          return !highlightAreas.has(this.dataset.cluster);
        });
        applyOpacity();
      });
    item.node().dataset.cluster = name;
    item.append("div").attr("class", "legend-dot").style("background", color);
    item.append("span").text(`${name} (${count})`);
  });
}

function setupControls() {
  d3.selectAll(".ctrl-btn").on("click", function() {
    d3.selectAll(".ctrl-btn").classed("active", false);
    d3.select(this).classed("active", true);
    edgeFilter = this.dataset.edge;
    update();
  });

  d3.select("#weight-slider").on("input", function() {
    weightThreshold = +this.value;
    d3.select("#weight-val").text(this.value);
    update();
  });
}

function showTooltip(event, d) {
  const tip = d3.select("#tooltip");
  let html = `<h4>${d.id}</h4>`;

  // Area tags — show all areas
  if (d.areas && d.areas.length) {
    html += `<div class="area-tags">`;
    d.areas.forEach(a => {
      const color = COLORS[a.area] || COLORS["Other"];
      const pct = Math.round(a.share * 100);
      html += `<span class="area-tag" style="background:${color}33;color:${color}">${a.area} ${pct}%</span>`;
    });
    html += `</div>`;
  }

  if (d.citedby) html += `<div class="stat">${d.citedby.toLocaleString()} citations &middot; h-index ${d.hindex}</div>`;
  if (d.interests && d.interests.length) {
    html += `<div class="topics">${d.interests.slice(0, 5).join(" &middot; ")}</div>`;
  }
  tip.html(html)
    .style("left", (event.clientX + 16) + "px")
    .style("top", (event.clientY - 10) + "px")
    .classed("visible", true);
}

function hideTooltip() {
  d3.select("#tooltip").classed("visible", false);
}

function showEdgeTooltip(event, d) {
  const tip = d3.select("#edge-tooltip");
  const src = typeof d.source === 'object' ? d.source.id : d.source;
  const tgt = typeof d.target === 'object' ? d.target.id : d.target;

  let html = `<h4>${src} &harr; ${tgt}</h4>`;
  if (d.coauthor_count) html += `<div class="edge-detail">co-authored ${d.coauthor_count} papers</div>`;
  if (d.shared_topics) html += `<div class="edge-detail">${d.shared_topics} shared topics</div>`;
  if (d.shared_journals) html += `<div class="edge-detail">${d.shared_journals} shared journals</div>`;
  if (d.coauthor_papers && d.coauthor_papers.length) {
    html += `<div class="paper-list"><strong>Papers:</strong><br>`;
    html += d.coauthor_papers.slice(0, 5).map(p => `&middot; ${p}`).join("<br>");
    if (d.coauthor_papers.length > 5) html += `<br>&hellip; and ${d.coauthor_papers.length - 5} more`;
    html += `</div>`;
  }

  tip.html(html)
    .style("left", (event.clientX + 16) + "px")
    .style("top", (event.clientY - 10) + "px")
    .classed("visible", true);
}

function hideEdgeTooltip() {
  d3.select("#edge-tooltip").classed("visible", false);
}

let hoverHighlightActive = false;

function highlightNeighbors(d) {
  if (document.getElementById("detail-panel").classList.contains("open")) return;
  hoverHighlightActive = true;
  const neighbors = new Set();
  const filteredEdges = getFilteredEdges();
  filteredEdges.forEach(e => {
    const src = typeof e.source === 'object' ? e.source.id : e.source;
    const tgt = typeof e.target === 'object' ? e.target.id : e.target;
    if (src === d.id) neighbors.add(tgt);
    if (tgt === d.id) neighbors.add(src);
  });
  neighbors.add(d.id);

  node.selectAll(".ring-slice")
    .attr("fill-opacity", function() {
      const nd = d3.select(this.parentNode).datum();
      return neighbors.has(nd.id) ? 0.85 : 0.1;
    });
  node.select("circle")
    .attr("stroke-opacity", function() {
      const nd = d3.select(this.parentNode).datum();
      return neighbors.has(nd.id) ? 0.3 : 0.05;
    });
  node.select("text")
    .attr("opacity", n => neighbors.has(n.id) ? 1 : 0.12);
  link.attr("opacity", e => {
    const src = typeof e.source === 'object' ? e.source.id : e.source;
    const tgt = typeof e.target === 'object' ? e.target.id : e.target;
    return (src === d.id || tgt === d.id) ? 1 : 0.05;
  });
}

function unhighlightNeighbors() {
  if (!hoverHighlightActive) return;
  hoverHighlightActive = false;
  applyOpacity();
}

let panelTarget = null;  // track what's shown in the panel

function clickNode(event, d) {
  event.stopPropagation();
  hideTooltip();
  if (panelTarget === d.id) { closePanel(); return; }
  showNodePanel(d);
}

function clickEdge(event, d) {
  event.stopPropagation();
  hideEdgeTooltip();
  const src = typeof d.source === 'object' ? d.source.id : d.source;
  const tgt = typeof d.target === 'object' ? d.target.id : d.target;
  const key = `${src}--${tgt}`;
  if (panelTarget === key) { closePanel(); return; }
  showEdgePanel(d);
}

function showNodePanel(d) {
  panelTarget = d.id;
  const panel = document.getElementById("detail-panel");
  document.getElementById("panel-title").textContent = d.id;

  const filteredEdges = getFilteredEdges();
  let html = "";

  // Area tags
  if (d.areas && d.areas.length) {
    html += `<div class="panel-section"><div class="panel-tags">`;
    d.areas.forEach(a => {
      const color = COLORS[a.area] || COLORS["Other"];
      const pct = Math.round(a.share * 100);
      html += `<span class="panel-tag" style="background:${color}33;color:${color}">${a.area} ${pct}%</span>`;
    });
    html += `</div></div>`;
  }

  // Stats
  html += `<div class="panel-section">`;
  if (d.citedby) html += `<div class="panel-stat"><strong>${d.citedby.toLocaleString()}</strong> citations</div>`;
  if (d.hindex) html += `<div class="panel-stat"><strong>${d.hindex}</strong> h-index</div>`;
  if (d.website) {
    html += `<a class="panel-link" href="${d.website}" target="_blank">Personal website &rarr;</a><br>`;
  }
  if (d.scholar_id) {
    html += `<a class="panel-link" href="https://scholar.google.com/citations?user=${d.scholar_id}" target="_blank">Google Scholar &rarr;</a>`;
  }
  html += `</div>`;

  // Research interests
  if (d.interests && d.interests.length) {
    html += `<div class="panel-section"><h4>Research Interests</h4>`;
    html += `<div class="topic-list">${d.interests.join(" &middot; ")}</div></div>`;
  }

  // Top publications
  if (d.top_pubs && d.top_pubs.length) {
    html += `<div class="panel-section"><h4>Recent Work</h4>`;
    d.top_pubs.forEach(p => {
      html += `<div class="paper-item"><div class="paper-title">${p.title}</div>`;
      html += `<div class="paper-meta">${p.year || ""}</div></div>`;
    });
    html += `</div>`;
  }

  // Strongest connections
  const connections = [];
  filteredEdges.forEach(e => {
    const src = typeof e.source === 'object' ? e.source.id : e.source;
    const tgt = typeof e.target === 'object' ? e.target.id : e.target;
    if (src === d.id) connections.push({ name: tgt, weight: e.weight, edge: e });
    if (tgt === d.id) connections.push({ name: src, weight: e.weight, edge: e });
  });
  connections.sort((a, b) => b.weight - a.weight);

  if (connections.length) {
    html += `<div class="panel-section"><h4>Connections in the Department</h4>`;
    connections.slice(0, 8).forEach(c => {
      const bits = [];
      if (c.edge.coauthor_count) bits.push(`co-authored ${c.edge.coauthor_count} paper${c.edge.coauthor_count > 1 ? "s" : ""}`);
      else if (c.edge.website_coauthor) bits.push("work in progress together");
      if (c.edge.shared_topics) bits.push(`${c.edge.shared_topics} shared topics`);
      if (c.edge.shared_journals) bits.push(`${c.edge.shared_journals} shared journals`);
      const detail = bits.length ? bits.join(", ") : "related research";
      html += `<div class="conn-item" data-name="${c.name}">${c.name}<span style="color:#555"> &mdash; ${detail}</span></div>`;
    });
    html += `</div>`;
  }

  document.getElementById("panel-body").innerHTML = html;
  panel.classList.add("open");

  // Make connection items clickable — open that node's panel
  panel.querySelectorAll(".conn-item[data-name]").forEach(el => {
    el.addEventListener("click", () => {
      const target = graph.nodes.find(n => n.id === el.dataset.name);
      if (target) showNodePanel(target);
    });
  });

  // Click background to close
  svg.on("click.panel", function(ev) {
    if (ev.target.tagName === "svg" || ev.target === this) {
      closePanel();
    }
  });
}

function showEdgePanel(d) {
  const src = typeof d.source === 'object' ? d.source.id : d.source;
  const tgt = typeof d.target === 'object' ? d.target.id : d.target;
  panelTarget = `${src}--${tgt}`;

  const panel = document.getElementById("detail-panel");
  document.getElementById("panel-title").innerHTML = `${src} &harr; ${tgt}`;

  let html = "";

  // Summary line
  const summaryBits = [];
  if (d.coauthor_count) summaryBits.push(`co-authored ${d.coauthor_count} paper${d.coauthor_count > 1 ? "s" : ""}`);
  else if (d.website_coauthor) summaryBits.push("have joint work in progress");
  if (d.shared_topics) summaryBits.push(`${d.shared_topics} shared research topics`);
  if (d.shared_journals) summaryBits.push(`${d.shared_journals} shared journals`);
  if (d.shared_refs) summaryBits.push(`cite ${d.shared_refs} of the same papers`);
  if (summaryBits.length) {
    html += `<div class="panel-section"><div class="panel-stat">${summaryBits.join(" &middot; ")}</div></div>`;
  }

  // Co-authored papers
  if (d.coauthor_papers && d.coauthor_papers.length) {
    html += `<div class="panel-section"><h4>Papers Written Together</h4>`;
    d.coauthor_papers.forEach(p => {
      html += `<div class="paper-item"><div class="paper-title">${p}</div></div>`;
    });
    html += `</div>`;
  }

  // Shared topics
  if (d.shared_topic_names && d.shared_topic_names.length) {
    html += `<div class="panel-section"><h4>Research Topics in Common</h4>`;
    html += `<div class="topic-list">${d.shared_topic_names.join(" &middot; ")}</div></div>`;
  }

  // Shared journals
  if (d.shared_journal_names && d.shared_journal_names.length) {
    html += `<div class="panel-section"><h4>Both Publish In</h4>`;
    html += `<div class="journal-list">${d.shared_journal_names.join(" &middot; ")}</div></div>`;
  }

  // Shared references (resolved titles)
  if (d.shared_ref_papers && d.shared_ref_papers.length) {
    html += `<div class="panel-section"><h4>Papers Both Have Cited</h4>`;
    d.shared_ref_papers.forEach(p => {
      html += `<div class="paper-item"><div class="paper-title">${p.title || "Untitled"}</div>`;
      const meta = [p.year, p.authors ? p.authors.join(", ") : ""].filter(Boolean).join(" &middot; ");
      if (meta) html += `<div class="paper-meta">${meta}</div>`;
      html += `</div>`;
    });
    html += `</div>`;
  }

  // Links to each person
  const srcNode = graph.nodes.find(n => n.id === src);
  const tgtNode = graph.nodes.find(n => n.id === tgt);
  html += `<div class="panel-section"><h4>View Profile</h4>`;
  [srcNode, tgtNode].forEach(n => {
    if (n) {
      html += `<div class="conn-item" data-name="${n.id}">${n.id}</div>`;
    }
  });
  html += `</div>`;

  document.getElementById("panel-body").innerHTML = html;
  panel.classList.add("open");

  // Make profile links clickable
  panel.querySelectorAll(".conn-item[data-name]").forEach(el => {
    el.addEventListener("click", () => {
      const target = graph.nodes.find(n => n.id === el.dataset.name);
      if (target) showNodePanel(target);
    });
  });

  svg.on("click.panel", function(ev) {
    if (ev.target.tagName === "svg" || ev.target === this) {
      closePanel();
    }
  });
}

function closePanel() {
  panelTarget = null;
  document.getElementById("detail-panel").classList.remove("open");
  svg.on("click.panel", null);
  applyOpacity();
}

function dragStart(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragging(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}

function dragEnd(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

init();
</script>
</body>
</html>
